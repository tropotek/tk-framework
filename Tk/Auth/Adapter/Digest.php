<?php
namespace Tk\Auth\Adapter;

use Tk\Auth\Result;

/**
 * Digest Authentication adapter
 *
 * This object uses a .htpasswd file or similar generated by the apache tools.
 *
 * This adapter requires that the password and username are submitted in a POST request
 *
 * @see https://en.wikipedia.org/wiki/Digest_access_authentication
 */
class Digest extends AdapterInterface
{

    protected string $scheme = 'basic';

    protected string $realm = '';

    /**
     * Full path to the digest password file
     */
    protected string $file = '';


    public function __construct(string $file, string $realm, $scheme)
    {
        $this->file = $file;
        $this->scheme = $scheme;
        $this->realm = $realm;
        if (!is_file($this->file)) {
            throw new \Tk\Exception('Cannot locate digest file: ' . $this->file);
        }
    }

    public function authenticate(): Result
    {
        // get values from a post request only
        $username = trim($_POST['username'] ?? '');
        $password = trim($_POST['password'] ?? '');

        if (false === ($fileHandle = @fopen($this->file, 'r'))) {
            return new Result(Result::FAILURE, $username, 'System authentication error.');
        }
        $id = $username . ':' . $this->realm;
        $idLength = strlen($id);
        while ($line = trim(fgets($fileHandle))) {
            if (substr($line, 0, $idLength) === $id) {
                if ( $this->_secureStringCompare(substr($line, -32), hash('md5', sprintf('%s:%s:%s', $username, $this->realm, $password))) ) {
                    return new Result(Result::SUCCESS, $username);
                } else {
                    return new Result(Result::FAILURE_CREDENTIAL_INVALID, $username, 'Username or Password incorrect');
                }
            }
        }
        return new Result(Result::FAILURE_IDENTITY_NOT_FOUND, $username, 'Invalid username or password.');
    }

    /**
     * Securely compare two strings for equality while avoided C level memcmp()
     * optimizations capable of leaking timing information useful to an attacker
     * attempting to iteratively guess the unknown string (e.g. password) being
     * compared against.
     */
    protected function _secureStringCompare(string $a, string $b): bool
    {
        if (strlen($a) !== strlen($b)) {
            return false;
        }
        $result = 0;
        for ($i = 0; $i < strlen($a); $i++) {
            $result |= ord($a[$i]) ^ ord($b[$i]);
        }
        return $result == 0;
    }
}

